---
layout:     post
title:      排序算法之冒泡排序
subtitle:   冒泡排序
date:       2017-07-11
author:     DH
header-img: img/post-bg-ioses.jpg
catalog: true
tags:
    - 算法
    - 排序
---
#### 思想

冒泡排序的思想就是，两两比较相邻的两个数，按照升序或者降序进行交换。这样交换一趟之后，最大或者最小的数字就被交换到最后一位，
接着从头开始，继续进行迭代的比较，直到倒数第二位，以此类推。

#### 例子

例如要对  6 7 4  1 5 9 进行升序的冒泡排序操作，过程如下：

- **第一趟**

第一次比较6和7 6 < 7,不交换
交换前状态 | 6 | 7 | 4 | 1 | 5 | 9 |
交换后状态 | 6 | 7 | 4 | 1 | 5 | 9 |

第二次比较7和4 7 > 4,交换
交换前状态 | 6 | 7 | 4 | 1 | 5 | 9 |
交换后状态 | 6 | 4 | 7 | 1 | 5 | 9 |

第三次比较7和1 7 > 1,交换
交换前状态 | 6 | 4 | 7 | 1 | 5 | 9 |
交换后状态 | 6 | 4 | 1 | 7 | 5 | 9 |

第四次比较7和5 7 > 5,交换
交换前状态 | 6 | 4 | 1 | 7 | 5 | 9 |
交换后状态 | 6 | 4 | 1 | 5 | 7 | 9 |

第五次比较7和9 9 > 7,不交换
交换前状态 | 6 | 4 | 1 | 5 | 7 | 9 |
交换后状态 | 6 | 4 | 1 | 5 | 7 | 9 |


- **第二趟**

第一次比较6和4 6 > 4,交换
交换前状态 | 6 | 4 | 1 | 5 | 7 | 9 |
交换后状态 | 4 | 6 | 1 | 5 | 7 | 9 |

第二次比较6和1 6 > 1,交换
交换前状态 | 4 | 6 | 1 | 5 | 7 | 9 |
交换后状态 | 4 | 1 | 6 | 5 | 7 | 9 |

第三次比较6和5 6 > 5,交换
交换前状态 | 4 | 1 | 6 | 5 | 7 | 9 |
交换后状态 | 4 | 1 | 5 | 6 | 7 | 9 |

第四次比较6和7 7 > 6,不交换
交换前状态 | 4 | 1 | 6 | 5 | 7 | 9 |
交换后状态 | 4 | 1 | 5 | 6 | 7 | 9 |

- **第三趟**

第一次比较4和1 4 > 1,交换
交换前状态 | 4 | 1 | 5 | 6 | 7 | 9 |
交换后状态 | 1 | 4 | 5 | 6 | 7 | 9 |

第二次比较4和5 5 > 4,不交换
交换前状态 | 1 | 4 | 5 | 6 | 7 | 9 |
交换后状态 | 1 | 4 | 5 | 6 | 7 | 9 |

第三次比较5和6 6 > 5,不交换
交换前状态 | 1 | 4 | 5 | 6 | 7 | 9 |
交换后状态 | 1 | 4 | 5 | 6 | 7 | 9 |

- **第四趟**

不交换

- **第五趟**

不交换

#### 分析

可以看到，一共需要n -1趟，而每一趟有需要 n - 2次比较。
综上分析，需要两层循环，外循环确定趟数，内循环确定每一趟的次数。

#### 代码

```
  public void bubbleSort(int [] array){
    			int outNumber = array.length - 1; // 外循环次数，也就是趟数
    			for(int i = 0 ; i < outNumber; i++){
    				for (int j = 0; j < outNumber - 1; j++) {
						if (array[j] > array[j+1]) {
							int temp = array[j];
							array[j] = array[j + 1];
							array[j + 1] = temp;
						}
					}
    			}
    }		

```


