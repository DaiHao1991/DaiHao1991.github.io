---
layout:     post
title:      孩子们的游戏(圆圈中最后剩下的数)
subtitle:   约瑟夫环
date:       2017-07-20
author:     DH
header-img: img/post-bg-hacker.jpg
catalog: true
tags:
    - 算法
    - 剑指offer
    - 约瑟夫环
---
#### 题目

>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。
其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那
个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0...m-1报数....这
样下去....直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪
个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)

#### 分析1

从当前节点开始数，数到第m个就输出，如果数到最后还没有到m,就又回到链表头继续数。找到之后，删除当前链表的节点，并把指针前移一位。

#### 代码1

```
import java.util.ArrayList;
public class Solution {
    public int LastRemaining_Solution(int n, int m) {
        if (n<=0 || m <=0 ) {
			return -1;
		}
        
        ArrayList< Integer> list  = new ArrayList<>();
        
        for(int i = 0; i < n; i++){
        		list.add(i);
        }
        
        // 移动的步数
        int step = 0;
        // 链表对应的下标
        int index = -1;
        // 记录最终结果
        int result = -1;
        
        while(list.size() > 0){
        	
        		index++;
        		if (index == list.size() ) {
					index = 0;
				}
        		step++;
        		if (step == m) {
        			result = list.get(index);
				list.remove(index);
				index--;
				step = 0;
				}
        		
        }
        
    	 	return result; 
    }
}		

```

#### 分析2

上面的方法简介，也很容易理解，但是会重读的去遍历链表，因此不是时间复杂度O(m)最优的。

把n个人的编号改为0~n-1，然后对删除的过程进行分析。
第一个删除的数字是(m-1)%n，几位k，则剩余的编号为(0,1,...,k-1,k+1,...,n-1)，下次开始删除时，顺序为(k+1,...,n-1,0,1,...k-1)。
用f(n,m)表示从(0~n-1)开始删除后的最终结果。
用q(n-1,m)表示从(k+1,...,n-1,0,1,...k-1)开始删除后的最终结果。
则f(n,m)=q(n-1,m)。

下面把(k+1,...,n-1,0,1,...k-1)转换为(0~n-2)的形式，即
k+1对应0
k+2对于1
...
k-1对应n-2
转化函数设为p(x)=(x-k-1)%n, p(x)的你函数为p^(x)=(x+k+1)%n。
则f(n,m)=q(n-1,m)=p^(f(n-1,m))=(f(n-1,m)+k+1)%n，又因为k=(m-1)%n。
f(n,m)=(f(n-1,m)+m)%n;

最终的递推关系式为
f(1,m) = 0;             (n=1)
f(n,m)=(f(n-1,m)+m)%n; （n>1）


