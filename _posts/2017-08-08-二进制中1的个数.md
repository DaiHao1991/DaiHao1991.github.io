---
layout:     post
title:      二进制中1的个数
subtitle:   
date:       2017-08-08
author:     DH
header-img: img/post-bg-coffee.jpeg 
catalog: true
tags:
    - 算法
    - 二进制
---

#### 题目

>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。

#### 方法一

最容易想到的就是每次去判断二进制的最右边一位是不是1，然后右移一位，直到整个数的二进制变为0。那么要怎么判断最后一位是不是0呢，只需要和1进行与操作。

这个方法对于整数直接有效，但是负数的话，因为符号位是1，右移的时候最高位会补1，那么这个数永远不会为0，无法退出，进入死循环，我们可以直接将负数变成整数，
最后在结果上直接+1即可。

#### 代码一

```

public class offer11 {
	public static void main(String[] args) {
			offer11 offer111 = new offer11();
			System.out.println(offer111.NumberOf1(5));
	}
	
	public int NumberOf1(int n) {
		if (n == 0) {
			return 0;
		}
		int temp = n;
		int count = 0;
		if (temp < 0) {
			temp = temp * (-1);
		}
		while (temp !=  0) {
			
			if ((temp & 1) == 1) {
				count ++;
			}
			temp = temp >> 1;
		}
		return n> 0 ?count : (count+1);
	}
	
}
		

```

在eclipse里面亲测有效，但是牛客网测试无法通过：

![](https://ws3.sinaimg.cn/large/006tKfTcgy1ficlel111ij30hk0w8tb3.jpg)

#### 方法二

在方法一里面，我们是移动需要判断的数，导致了需要去进行正负数的不同处理，其实我们可以每次第一次判断最右边是不是1，然后从右到左第二位第三位，
只需要分别和0000 0001，0000 0010，0000 0100.....相与，也就是说我们可以每次将1左移一位，直到这个数变 == 0；

#### 代码二

```
public int NumberOf2(int n) {
		if (n == 0) {
			return 0;
		}
		
		int flag = 1;
		int count = 0;
		
		while (flag != 0) {
			
			if ((n & flag) != 0) {
				count +=1;
				System.out.println(count);
			}
			
			flag = flag << 1;
		}
		
		return count;
	}

```

这个在牛客网测试会通过


#### 方法三

其实方法二的复杂度也不是很高，只需要循环32次，但是不知道为啥牛客网不能通过。

举例子，6的二进制表示为0000 0110（一般都是用8位表示原码）。6-1，二进制的表示为：0000 0110 - 0000 0001，这个时候，遇到0000 0110从右到左，
第一个不为0的位，将其变为0，而这个位右边的全部变为1，也就是0000 0101。然后将0000 0101 与6 的原码进行“与”运算，即 0000 0101 & 0000 0110，
得到0000 0100，这样进行一次之后就将6的原码的最右边的1变为了0。按照这个思想，我们一直进行此过程，直到n等于0。


#### 代码三

```
public int  NumberOf3(int n){
		if(n == 0){
            return 0;
        }
        int countOfOne = 0;
        
        while(n != 0){
            n = n & (n - 1);
            countOfOne ++ ;
            
        }
        return countOfOne;
	}		

```
