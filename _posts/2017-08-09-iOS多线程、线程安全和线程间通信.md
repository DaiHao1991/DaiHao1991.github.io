---
layout:     post
title:      iOS多线程、线程安全和线程间通信
subtitle:   
date:       2017-08-09
author:     DH
header-img: img/post-bg-2015.jpg  
catalog: true
tags:
    - iOS
    - 多线程
    - 线程安全
    - 线程间通信
---


#### 多线程的概念

一个运行着的程序叫做一个进程，一个进程至少包含一个线程，线程是程序的执行流。在iOS中程序一旦启动就有一个线程一直运行，这个线程叫主线程。主线程是其他所
有线程的父线程。

系统中的所有县城共享进程的地址空间，所以能够自由的访问进程的空间变量。多线程访问的变量称之为“共享变量”。共享变量主要是“全局变量”和“静态变量”。

各个线程都有自己的栈，线程不能访问其他线程的的栈内变量。

进程是操作系统分配资源和调度的基本单位，线程是进程基本执行单位，一个进程对应多个线程。

线程又分为主线程和非主线程：

一般来说：主线程用于处理UI，所有的UI操作都要在主线程进行，耗时操作放在非主线程。

其实，CPU在一个单位时间只能处理一个线程（单CPU），但是可以通过快速的切换线程，就像同时在处理多个线程一样。

网上有一个比喻：

进程就是一列火车，线程是车厢，一列火车至少要有一节车厢，就如一个进程至少要有一个线程，车厢离开火车就无法运行，多个车厢可以提高运行效率。

多线程的目的就是提高系统的运行效率，将耗时操作都放在后台。

#### 互斥

在多线程的环境下，不同的线程可以同时操作某个资源，例如某些线程在读取某个数，而另外一些线程在写这个数，这个时候就很容易产生难以预料的结果，使得线程不安全，解决这个问题的方式就是让线程的操作互斥，主要使用互斥锁。

- **NSLock**

NSLock是基于信号量的，他只允许单个的线程获得并使用。

使用方法：

```
-(void)addNumber:(int)number{
    // 初始化一个锁
    NSLock *aLock = [[NSLock alloc]init];
    
    // 加锁
    [aLock lock];
    
    
    number ++; // 临界区
    
    // 解锁
    [aLock unlock];
}
		

```

- **NSConditionLock**

条件锁持有整形数值，根据这个值获得锁或者等待。

```
-(void)addNumber2:(int)number{
    // 初始化一个锁
    NSConditionLock *conditonLock = [[NSConditionLock alloc]initWithCondition:1];
    
    // 加锁
    [conditonLock lockWhenCondition:1];
    
    
    number ++; // 临界区
    
   
    // 解锁
    [conditonLock unlockWithCondition:0];
    
}
		

```

- **NSRecrusiveLock**

递归锁。某线程得到锁之后，想要获得该锁的线程就会进入休眠，使用NSLock时，如果获得锁的线程在没有释放的情况下，又再次获得这个锁，就会造成死锁。例如：

```
 // 加锁
    [aLock lock];
    [aLock lock];
    
    
    number ++; // 临界区
    
    // 解锁
    [aLock unlock];
    [aLock unlock];		

```

使用递归锁，同一个线程多次获得同一个锁，也不会产生死锁，只要最后获得的次数和释放的次数一致，就会释放锁。

- **synchronized**

程序块内的代码不能被多线程同时使用。

```
@synchronized (objct) {
        // 想要执行的代码
    }		

```
运行这一段代码时，运行时系统就创建排斥的执行该段代码的锁。

@synchronized(obj)指令使用的obj为该锁的唯一标识，只有当标识相同时，才为满足互斥，
如果线程2中的@synchronized(obj)改为@synchronized(self),那么线程2就不会被阻塞。


#### 线程的状态、转换和生命周期

线程的生命周期包括：新建--就绪--运行--阻塞--死亡，他们之间的转化如下图所示：

![](https://ws3.sinaimg.cn/large/006tNc79gy1fiks188a3dj313y0j2ju5.jpg)

新建：实例化对象

就绪：调用线程对象的start函数，线程被假如到可调度池，等待CPU调度

运行：CPU调度可调度池的线程。线程执行的过程中，可能会在就绪和运行状态之间切换。这些都是由CPU控制的。

阻塞：在满足某中条件的时候，正在运行的线程会从运行状态转化成阻塞状态，主要包括：sleepForTimeInterval（休眠指定时长），sleepUntilDate（休眠到指定日期），@synchronized(self)：（互斥锁）

死亡：线程运行完，正常结束。第二种是满足某种条件的时候，线程内部终止。

#### 四中多线程方案

包括pthread、NSthread、GCD、NSOperation

借用网友的一张图片进行概述：

![](https://ws1.sinaimg.cn/large/006tNc79gy1fiksgvg1rlj30yg0gv0yd.jpg)

#### 多线程安全

在多线程环境下，如果多个线程同时对某个资源进行读写操作，可能会导致数据错乱，出现难以预料的结果。

解决这个问题的方式就是给线程加锁。

（1）互斥锁

前面已经说过了，包括NSLock、NSConditionLock、@synchronized.

(2) 自旋锁

加了自旋锁，当新线程当问加锁的代码时，如果发现该段代码已经加锁，就会一直的等待这段代码执行完毕，解锁。相当于一直尝试执行这段代码，很耗性能。

#### atomic和nonatomic

定义属性的时候经常用到。

noatomic:非原子属性，同时可被多个线程读写，线程不安全，效率高
atomic：原子性，线程安全，同时只能被一个线程访问。

被atomic修饰的属性，会自动的在set方法中调用@synchronized（self）。所以效率很低，因为其实@synchronized会将他修饰的代码块加入到一个队列中，而同一时间，线程只能执行队列中的一个代码块，所以效率很低。
