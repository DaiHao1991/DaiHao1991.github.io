---
layout:     post
title:      iOS多线程、线程安全和线程间通信
subtitle:   
date:       2017-08-09
author:     DH
header-img: img/post-bg-2015.jpg  
catalog: true
tags:
    - iOS
    - 多线程
    - 线程安全
    - 线程间通信
---


#### 多线程的概念

一个运行着的程序叫做一个进程，一个进程至少包含一个线程，线程是程序的执行流。在iOS中程序一旦启动就有一个线程一直运行，这个线程叫主线程。主线程是其他所
有线程的父线程。

系统中的所有县城共享进程的地址空间，所以能够自由的访问进程的空间变量。多线程访问的变量称之为“共享变量”。共享变量主要是“全局变量”和“静态变量”。

各个线程都有自己的栈，线程不能访问其他线程的的栈内变量。

进程是操作系统分配资源和调度的基本单位，线程是进程基本执行单位，一个进程对应多个线程。

线程又分为主线程和非主线程：

一般来说：主线程用于处理UI，所有的UI操作都要在主线程进行，耗时操作放在非主线程。

其实，CPU在一个单位时间只能处理一个线程（单CPU），但是可以通过快速的切换线程，就像同时在处理多个线程一样。

网上有一个比喻：

进程就是一列火车，线程是车厢，一列火车至少要有一节车厢，就如一个进程至少要有一个线程，车厢离开火车就无法运行，多个车厢可以提高运行效率。

多线程的目的就是提高系统的运行效率，将耗时操作都放在后台。

#### 互斥

在多线程的环境下，不同的线程可以同时操作某个资源，例如某些线程在读取某个数，而另外一些线程在写这个数，这个时候就很容易产生难以预料的结果，使得线程不安全，解决这个问题的方式就是让线程的操作互斥，主要使用互斥锁。

- **NSLock**

NSLock是基于信号量的，他只允许单个的线程获得并使用。

使用方法：

```
-(void)addNumber:(int)number{
    // 初始化一个锁
    NSLock *aLock = [[NSLock alloc]init];
    
    // 加锁
    [aLock lock];
    
    
    number ++; // 临界区
    
    // 解锁
    [aLock unlock];
}
		

```

- **NSConditionLock**

条件锁持有整形数值，根据这个值获得锁或者等待。

```
-(void)addNumber2:(int)number{
    // 初始化一个锁
    NSConditionLock *conditonLock = [[NSConditionLock alloc]initWithCondition:1];
    
    // 加锁
    [conditonLock lockWhenCondition:1];
    
    
    number ++; // 临界区
    
   
    // 解锁
    [conditonLock unlockWithCondition:0];
    
}
		

```

- **NSRecrusiveLock**

递归锁。某线程得到锁之后，想要获得该锁的线程就会进入休眠，使用NSLock时，如果获得锁的线程在没有释放的情况下，又再次获得这个锁，就会造成死锁。例如：

```
 // 加锁
    [aLock lock];
    [aLock lock];
    
    
    number ++; // 临界区
    
    // 解锁
    [aLock unlock];
    [aLock unlock];		

```

使用递归锁，同一个线程多次获得同一个锁，也不会产生死锁，只要最后获得的次数和释放的次数一致，就会释放锁。

- **synchronized**

程序块内的代码不能被多线程同时使用。

```
@synchronized (objct) {
        // 想要执行的代码
    }		

```
运行这一段代码时，运行时系统就创建排斥的执行该段代码的锁。

@synchronized(obj)指令使用的obj为该锁的唯一标识，只有当标识相同时，才为满足互斥，
如果线程2中的@synchronized(obj)改为@synchronized(self),那么线程2就不会被阻塞。


#### 线程的状态、转换和生命周期

线程的生命周期包括：新建--就绪--运行--阻塞--死亡，他们之间的转化如下图所示：

![](https://ws3.sinaimg.cn/large/006tNc79gy1fiks188a3dj313y0j2ju5.jpg)

新建：实例化对象

就绪：调用线程对象的start函数，线程被假如到可调度池，等待CPU调度

运行：CPU调度可调度池的线程。线程执行的过程中，可能会在就绪和运行状态之间切换。这些都是由CPU控制的。

阻塞：在满足某中条件的时候，正在运行的线程会从运行状态转化成阻塞状态，主要包括：sleepForTimeInterval（休眠指定时长），sleepUntilDate（休眠到指定日期），@synchronized(self)：（互斥锁）

死亡：线程运行完，正常结束。第二种是满足某种条件的时候，线程内部终止。

#### 四中多线程方案

包括pthread、NSthread、GCD、NSOperation

借用网友的一张图片进行概述：

![](https://ws1.sinaimg.cn/large/006tNc79gy1fiksgvg1rlj30yg0gv0yd.jpg)

#### 多线程安全

在多线程环境下，如果多个线程同时对某个资源进行读写操作，可能会导致数据错乱，出现难以预料的结果。

解决这个问题的方式就是给线程加锁。

（1）互斥锁

前面已经说过了，包括NSLock、NSConditionLock、@synchronized.

(2) 自旋锁

加了自旋锁，当新线程当问加锁的代码时，如果发现该段代码已经加锁，就会一直的等待这段代码执行完毕，解锁。相当于一直尝试执行这段代码，很耗性能。

#### atomic和nonatomic

定义属性的时候经常用到。

noatomic:非原子属性，同时可被多个线程读写，线程不安全，效率高
atomic：原子性，线程安全，同时只能被一个线程访问。

被atomic修饰的属性，会自动的在set方法中调用@synchronized（self）。所以效率很低，因为其实@synchronized会将他修饰的代码块加入到一个队列中，而同一时间，线程只能执行队列中的一个代码块，所以效率很低。

#### NSThread

- **NSThread创建**

(1)初始化方式，然后调用start函数

```
    // 创建一个线程，处于创建状态
    NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(test) object:nil];
    
    // 调用线程的start方法，线程处于可运行状态，被加入到可调度线程池等待CPU的调度。
    [thread start];		

    // 创建一个线程，处于创建状态
    NSThread *thread2 = [[NSThread alloc]initWithBlock:^{
        // 线程中要运行的代码
    }];
    // 调用线程的start方法，线程处于可运行状态，被加入到可调度线程池等待CPU的调度。
    [thread2 start];

```


(2)类方法创建线程

2.1 detachNewThreadSelector

这个类方法，直接创建好线程，并且将线程放到可调度池，线程自动启动。
```
    // 线程创建好之后，自动启动
    [NSThread detachNewThreadSelector:@selector(test) toTarget:self withObject:nil];
    
    [NSThread detachNewThreadWithBlock:^{
    // 线程创建好之后，自动启动
    }];

```

2.2 detachNewThreadSelector

这个类方法，直接创建好线程，并且将线程放到可调度池，线程自动启动。
```
    // 线程创建好之后，自动启动
    [NSThread detachNewThreadSelector:@selector(test) toTarget:self withObject:nil];
    
    [NSThread detachNewThreadWithBlock:^{
    // 线程创建好之后，自动启动
    }];


```

2.3 performSelectorInBackground

这个方法现在用的不多，隐式创建一个线程，直接启动

```
    // 隐式创建，现在用的不多，直接创建好就启动
    [self performSelectorInBackground:@selector(test) withObject:nil];		

```


- **NSThread类方法**

（1）[NSThread exit];   终止线程

（2）[NSThread currentThread];    返回当前线程的线程号和名字，线程号1表示主线程。

（3）[NSThread sleepForTimeInterval:10];    线程休眠10秒

（4）[NSThread sleepUntilDate:[NSData data]];    线程休眠到某个指定时间

（5）[NSThread isMainThread];    当前线程是不是主线程

（6）[NSThread isMultiThreaded];    当前情况是都存在多线程

（7）NSThread *mainThread = [NSThread mainThread];   取得主线程

- **NSThread属性**

（1）thread.isExecuting;    线程是否在执行

（2）thread.isCancelled;    线程是否被取消

（3）thread.isFinished;    线程是否完成

（4）thread.isMainThread;   是否是主线程

（5）thread.threadPriority;   线程的优先级，取值范围0.0到1.0，默认优先级0.5，1.0表示最高优先级，优先级高，CPU调度的频率高

#### GCD

GCD是异步执行任务的技术之一，开发者只需要定义要执行的任务，然后追加这些任务到GCD的队列，GCD就能生成必要的线程执行相应的任务。

线程作为管理作为系统的一部分，深入内核，所以效率非常高。

- **GCD中的概念说明**

（1）任务

任务就是程序员想要完成的操作或者功能，在GCD中，我们一般都将任务封装成一个block（也就是一个匿名函数，或者理解成代码段）。然后程序员自行决定添加到串行队列或者并行队列，程序员的工作就完成了，接着等待CPU的调度。

（2）同步（sync）和异步（asycn）

同步和异步决定了是否要新开线程。

同步：不开新的线程，任务一个执行完之后执行队列中的下一个任务；

异步：开启新的线程，多个任务可以在多个线程中一起执行；

（3）串行队列和并行队列

串行队列：我理解的是任务像珠子一样被穿在一起，只有一个一个的顺序执行

并行队列：队列中的任务会被多个线程同时执行

（4）主队列和全局队列

主队列：一个应用中只有一个主队列，是串行队列

全局队列：并行队列，系统分配，无需创建

我们在使用GCD的时候，只需要将任务添加到队列，然后指定任务执行的方式是同步还是异步，就OK了。


- **队列的创建**

（1）并行队列
```
dispatch_queue_t queue = dispatch_queue_create("queue1", DISPATCH_QUEUE_SERIAL);		

```

（2）串行队列

```
dispatch_queue_t queue2 = dispatch_queue_create("queue2", DISPATCH_QUEUE_CONCURRENT);		

```

全局队列和主队列不能创建，只能取得。

（3）全局队列

全局队列的优先级包括：
#define DISPATCH_QUEUE_PRIORITY_HIGH 2 // 高优先级
#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0 // 默认（中）优先级
#define DISPATCH_QUEUE_PRIORITY_LOW (-2) // 低优先级
#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN // 后台优先级

```
// 第一个参数是优先级
//iOS8开始使用服务质量，现在获取全局并发队列时，可以直接传0
dispatch_queue_t globleQueue = dispatch_get_global_queue(0, 0);		

```

（4）主队列

主队列一般只能用于更新UI

```
dispatch_queue_t mainQueue = dispatch_get_main_queue();		

```

#### 同步和异步任务的创建

- **同步的创建**

```
dispatch_sync(dispatch_get_global_queue(0, 0), ^{
        // 任务
        NSLog(@"dslfhl");
    });	

```

- **异步的创建**

```
dispatch_async(dispatch_get_global_queue(0, 0), ^{
        // 任务
        NSLog(@"dslfhl");
    });	

```


#### GCD中同步/异步和并行/串行的组合

一共有四种队列和两种执行方式，可以进行组合：

- **串行同步**

只要有同步就不会产生新的线程，串行会一个一个顺序执行，因此串行同步不产生新线程，在当前线程中顺序执行。

例子如下：

```
    // 创建串行队列
    dispatch_queue_t queue = dispatch_queue_create("queue", DISPATCH_QUEUE_SERIAL);
    
    dispatch_sync(queue, ^{
        NSLog(@"串行同步--任务1--线程是：%@",[NSThread currentThread]);
    });
    
    dispatch_sync(queue, ^{
        NSLog(@"串行同步--任务2--线程是：%@",[NSThread currentThread]);
    });


```

输出结果是：

```
2017-08-16 17:08:59.912 TestNew[2972:1293325] 串行同步--任务1--线程是：<NSThread: 0x608000261dc0>{number = 1, name = main}
2017-08-16 17:08:59.912 TestNew[2972:1293325] 串行同步--任务2--线程是：<NSThread: 0x608000261dc0>{number = 1, name = main}
2017-08-16 17:08:59.912 TestNew[2972:1293325] 串行同步--任务3--线程是：<NSThread: 0x608000261dc0>{number = 1, name = main}

```

观察结果可以发现，虽然我们创建了一个线程，但是最后还是使用的主线程，没有创建新的线程，并且顺序执行。

- **串行异步**

串行队列中的任务只能一个一个执行，而异步可以开启多个线程。所以串行异步的结果是开启新的线程，任务顺序执行

```
 // 创建串行队列
    dispatch_queue_t queue = dispatch_queue_create("queue", DISPATCH_QUEUE_SERIAL);
    
    dispatch_async(queue, ^{
        NSLog(@"串行异步--任务1--线程是：%@",[NSThread currentThread]);
    });
    
    dispatch_async(queue, ^{
        NSLog(@"串行异步--任务2--线程是：%@",[NSThread currentThread]);
    });
    
    dispatch_async(queue, ^{
        NSLog(@"串行异步--任务3--线程是：%@",[NSThread currentThread]);
    });

```

输出结果：

```
2017-08-16 17:15:49.653 TestNew[3051:1325440] 串行异步--任务1--线程是：<NSThread: 0x60800006ed80>{number = 3, name = (null)}
2017-08-16 17:15:49.654 TestNew[3051:1325440] 串行异步--任务2--线程是：<NSThread: 0x60800006ed80>{number = 3, name = (null)}
2017-08-16 17:15:49.654 TestNew[3051:1325440] 串行异步--任务3--线程是：<NSThread: 0x60800006ed80>{number = 3, name = (null)}

```

可以看到创建了一个number = 3的新线程，任务顺序执行。

- **并行同步**

同步表示不开启新的线程，因此执行结果是任务顺序执行，不开启新的线程

```
// 创建并行队列
    dispatch_queue_t queue = dispatch_queue_create("queue", DISPATCH_QUEUE_CONCURRENT);
    
    dispatch_sync(queue, ^{
        NSLog(@"并行同步--任务1--线程是：%@",[NSThread currentThread]);
    });
    
    dispatch_sync(queue, ^{
        NSLog(@"并行同步--任务2--线程是：%@",[NSThread currentThread]);
    });
    
    dispatch_sync(queue, ^{
        NSLog(@"并行同步--任务3--线程是：%@",[NSThread currentThread]);
    });
		

```

输出结果是：

```
2017-08-16 17:25:46.613 TestNew[3142:1360637] 并行同步--任务1--线程是：<NSThread: 0x60800006d280>{number = 1, name = main}
2017-08-16 17:25:46.613 TestNew[3142:1360637] 并行同步--任务2--线程是：<NSThread: 0x60800006d280>{number = 1, name = main}
2017-08-16 17:25:46.613 TestNew[3142:1360637] 并行同步--任务3--线程是：<NSThread: 0x60800006d280>{number = 1, name = main}

```

- **并行异步**

并行表示多个任务可以同时被执行，异步会开启新的线程，所以并行异步会开启多线程，并且异步执行

```
// 创建并行队列
    dispatch_queue_t queue = dispatch_queue_create("queue", DISPATCH_QUEUE_CONCURRENT);
    
    dispatch_async(queue, ^{
        NSLog(@"并行异步--任务1--线程是：%@",[NSThread currentThread]);
    });
    
    dispatch_async(queue, ^{
        NSLog(@"并行异步--任务2--线程是：%@",[NSThread currentThread]);
    });
    
    dispatch_async(queue, ^{
        NSLog(@"并行异步--任务3--线程是：%@",[NSThread currentThread]);
    });

		

```

输出结果是：

```
2017-08-16 19:54:07.557 TestNew[3498:1450488] 并行异步--任务2--线程是：<NSThread: 0x60800007a100>{number = 4, name = (null)}
2017-08-16 19:54:07.557 TestNew[3498:1450485] 并行异步--任务3--线程是：<NSThread: 0x60000007dd00>{number = 5, name = (null)}
2017-08-16 19:54:07.557 TestNew[3498:1450517] 并行异步--任务1--线程是：<NSThread: 0x60000007e080>{number = 3, name = (null)}
```


可以看到开启了多个线程，任务执行顺序也不一定。

