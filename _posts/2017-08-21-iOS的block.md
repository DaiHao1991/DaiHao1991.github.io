---
layout:     post
title:      iOS的block
subtitle:   
date:       2017-08-21
author:     DH
header-img: img/post-bg-ioses.jpg 
catalog: true
tags:
    - iOS
    - block
---


# block概述

《Objective-c高级编程》中描述block是带有自动变量（局部变量）的匿名函数。

我的理解就是可以直接在一段代码中插入一个函数，而不用显示的去掉用这个函数。

#### block基本语法

```
^返回值 参数列表{};

// 返回值是整数，两个参数
^int(int i,int j){
            return  i+j;
        };

// 无返回值，参数两个
^(int i,int j){
           
        };
        
// 无参数，无返回值
^{};

```

#### 将block作为变量（block变量）

blick可以作为变量，与一般OC（或者说C）的变量完全一样，可以作为：自动变量（局部变量）、静态变量、全局变量、函数参数、静态全局变量。

语法：

```
//
//  main.m
//  DemoBlock
//
//  Created by DH on 2017/8/21.
//  Copyright © 2017年 GreedyCat. All rights reserved.
//

#import <Foundation/Foundation.h>

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        
        int (^block)(int) = ^(int i){return i;};
        
        block(1);
        
    }
    return 0;
}


```

#### block截取自动变量

《Objective-c高级编程》中描述block是带有自动变量（局部变量）的匿名函数。这个自动变量就表现在block对在他之前声明的自动变量的值的获取，这里的获取，需要
特别的注意，获取的是自动变量的瞬间值，block保存了自动变量的值，在block执行之后，即使改变了block中使用的自动变量的值，也不会影响block执行时自动变量的值。

举一个例子：

```
//
//  main.m
//  DemoBlock
//
//  Created by DH on 2017/8/21.
//  Copyright © 2017年 GreedyCat. All rights reserved.
//

#import <Foundation/Foundation.h>

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        
        int i = 1;
        int j = 1;
        
        void (^block)(void) = ^{NSLog(@"%d",i+j);};
        
        block();
        
        i = 10;
        
        block();

        
    }
    return 0;
}

```
输出结果是：

```
2017-08-21 17:21:45.170390+0800 DemoBlock[2638:1592472] 2
2017-08-21 17:21:45.171136+0800 DemoBlock[2638:1592472] 2
Program ended with exit code: 0
```

我们可以看到，在第二次输出的依然是2，而不是11，也就说明了block捕获的是瞬间值。

#### __block修饰符

从上面一个例子知道，我们可以在block中截取自动变量的值，但是这个是只读的，我们不能修改block以外的自动变量的值，假如我们想要在block中修改上个例子中的i的值，
我们就要在i前面加一个__block修饰符。

```
//
//  main.m
//  DemoBlock
//
//  Created by DH on 2017/8/21.
//  Copyright © 2017年 GreedyCat. All rights reserved.
//

#import <Foundation/Foundation.h>

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        
        __block int i = 1;
        
        
        void (^block)(void) = ^{i=2;};
        
        block();
        
        NSLog(@"在block中修改自动变量的值---%d",i);

        
    }
    return 0;
}

```

输出结果：

```
2017-08-21 19:36:34.321111+0800 DemoBlock[3090:1927645] 在block中修改自动变量的值---2
Program ended with exit code: 0

```

# block的实现

我们通过clang -rewrite-objc将源代码转化成C++语言，看看block的底层是怎么实现的。

原OC代码是：

```
//
//  main.m
//  DemoBlock
//
//  Created by DH on 2017/8/21.
//  Copyright © 2017年 GreedyCat. All rights reserved.
//

#import <Foundation/Foundation.h>

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        
        void (^blk) (void) = ^{};
        blk();

        
        
    }
    return 0;
}
		

```

转换成C++代码（部分）如下：

```
struct __block_impl {
  void *isa;
  int Flags;
  int Reserved;
  void *FuncPtr;
};

struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {
    impl.isa = &_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
}

static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};
int main(int argc, const char * argv[]) {
    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; 

        void (*blk) (void) = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA));
        ((void (*)(__block_impl *))((__block_impl *)blk)->FuncPtr)((__block_impl *)blk);



    }
    return 0;
}


```

我们来分析一下这部分转化的代码,如下图：

![](https://ws3.sinaimg.cn/large/006tKfTcgy1fisasnhz1xj30yc0epq7n.jpg)

经过编译，我们知道block其实就是一个结构体，从上图可以看出：

main函数的参数__cself 指向 __main_block_impl_0：

```
struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {
    impl.isa = &_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};		

```

impl_0表示是main函数中的第1个block。这个结构体包含两个部分：

（1）结构题：__block_impl;
```
struct __block_impl {
  void *isa;
  int Flags;
  int Reserved;
  void *FuncPtr;
};		

```

isa指针指向该对象对应的类，也就是block，我们可以看出其实block是一个OC对象（在runtime中对象和类都是用结构体表示）。

flags标志位

reserved 保留变量

FuncPtr block执行时调用的函数指针。

（2）Desc指针。

Desc指向的结构体__main_block_desc_0

```
static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};		

```
包含两个部分;

（1）reseverd 版本升级需要的区域

（2）block的大小

同时，还创建了__main_block_desc_0_DATA，在__main_block_impl_0初始化时使用。


接下来我们重点来看看__main_block_impl_0的构造函数：

```
__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {
 impl.isa = &_NSConcreteStackBlock;
 impl.Flags = flags;
 impl.FuncPtr = fp;
 Desc = desc;
 }
 
```

首先，我们来看看main函数中是怎么对这个构造函数进行调用的：

```
int main(int argc, const char * argv[]) {
    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; 

	
        void (*blk) (void) = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA));
        ((void (*)(__block_impl *))((__block_impl *)blk)->FuncPtr)((__block_impl *)blk);

    }
    return 0;
}
 
```

((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA))这一句就是对__main_block_impl_0构造函数
的调用。

第一个参数__main_block_func_0是转换成C语言的函数指针，第二个参数是初始化__main_block_impl_0结构体实例的结构体，和__main_block_impl_0的大小有关。

我们再回到__main_block_impl_0的狗在函数，这个构造函数初始化了四个变量：

isa指针指向一个_NSConcreteStackBlock；

FuncPtr指向__main_block_func_0；

desc指向__main_block_desc_0创建时的__main_block_desc_0_DATA，主要是用于初始化__main_block_impl_0的大小。


总的来说,我自己理解是两句话;

（1）block的实质是一个结构体，这个结构体包含了定义block时代码块的函数指针（FuncPtr或者说_cself）和block外部上下文变量等信息

（2）block是一个OC对象，这点从

