---
layout:     post
title:      5. Harmony 状态装饰器
subtitle:   
date:       2024-11-27
author:     DH
header-img: img/post-bg-digital-native.jpg 
catalog: true
tags:
    - 鸿蒙
    - 鸿蒙基础
    - Harmony
---
### 状态修饰器

在鸿蒙上，状态装饰器用于修饰状态变量，当状态变量改变时，根据不同的状态装饰器进行相应的响应式UI刷新

### 各状态装饰器

#### @State

.被@State修饰的变量作用域是组件内部;

.其修饰的变量生命周期和其自定义组件的生命周期相同;

.必须进行初始化

.当装饰器修饰的是基本类型、对象时，数据的变化可以被装饰器发现。当修饰数组时，数组的增删可以被观察，但是数组内某个对象的属性被修改时，不会引起刷新

#### @Prop

父组件传值给子组件，如果父组件中的值修改时，子组件的变量还是用@State修饰，并不是引起UI的刷新。这时需要对子组件中的状态变量使用@Prop修饰

子组件的修改不能同步到父组件！

```
@Entry
@Component
struct PropDemoPage{
  @State name :string= "张三";
  build() {
    Row(){
      childView({ childName:this.name} )

      Button("修改name")
        .onClick(()=>{
          this.name = "李四"
        })
    }
  }
}

@Component
struct childView{
  // 通过父组件传值
  @Prop childName:string = "";
  build() {
    Text(this.childName)
  }
}
```

子组件中被@Prop修饰的状态变量名字可以不用和父组件中被@State修饰的状态变量相同

#### @Link

@Prop(子组件) + @State(父组件) 只能实现父到子的同步刷新。如果想实现父子的双向同步更新，需要使用@link(子组件) + @State(父组件)。


