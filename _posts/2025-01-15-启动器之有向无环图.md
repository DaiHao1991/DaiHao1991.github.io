---
layout:     post
title:      启动器之有向无环图
subtitle:   启动器原理-有向无环图。
date:       2025-01-15
author:     DH
header-img: img/post-bg-2015.jpg 
catalog: true
tags:
    - 启动器
    - 有向无环图
    - 性能优化
---
#### 简介

>APP启动时，有很多初始化工作需要进行，例如引入了很多第三方SDK后，都需要在程序启动时进行初始化，这是一个耗时的过程，性能优化时，可以将任务放在子线程，所有任务完成之后，进入主页。但是这样存在一个问题，如果任务之间存在依赖，无法控制初始化顺序。如果放到主线程顺序执行，性能又很差。这个时候就需要启动器，控制初始化顺序。

#### 分析

![image](https://github.com/user-attachments/assets/5c772727-d4de-4fd9-bd28-4497bc95e933)

可以把图中的节点看成是初始化任务，要执行任务3，必须先完成任务0和1，要执行任务4，必须先完成任务1和2，要执行任务5，必须先完成任务3和4。这就是有向无环图的拓扑排序。因此，对于APP的启动器，核心原理就是有向无环图。

有向无环图的拓扑排序，有两种算法：

（1）广度优先算法（BFS）

核心思想：

① 将入度为 0 的所有节点加入到队列；

② 队头任务出队列，将其后续节点的入度-1；

③ 将入度为 0 的节点加入队列；

④ 队列为空，且无入度为 0 的节点

（2）深度优先算法（DFS）

① 



#### 代码

```
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        if(list1 == null && list2 == null)
            return null;
        if(list1 == null)
        {
            return list2;
        }

        if(list2 == null){
            return list1;
        }

        // 创建一个新的节点，head指向最终合成的数列的最后节点
        ListNode head = new ListNode(0);
        ListNode newListHead = head;

        while(list1 != null && list2 != null){
            if(list1.val <= list2.val){
                head.next = list1;
                head = list1;
                list1 = list1.next;
            }else{
                head.next = list2;
                head = list2;
                list2 = list2.next;
            }
        }

        if(list1 != null){
            head.next = list1;
        }
        if(list2 != null){
            head.next = list2;
        }
        return newListHead.next;
    }
}		

```

考虑递归的形式，其实每一次就是调用相同的函数进行比较，输出小的，同时进行下一轮比较。 
思想很简单，但是递归不好理解，其实函数每一次调用的时候都是一次入栈的操作。 
每当运行一个函数时，就在栈顶分配空间，函数退出后，释放这块空间。所以当前运行的函数一定在栈顶。

所以每一次递归调用的时候，都会在栈顶给递归函数分配一块新的空间，当函数运行后，进行出栈操作，依次往下，最终完成递归的运算。 

就本题而言，举个例子 

1->2->8->9和3->4->6->7 

栈中的变化如下图所示： 

![](https://ws4.sinaimg.cn/large/006tNc79gy1fhgvscf29aj30cb0ad74w.jpg)

#### 代码二

```
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        if(list1 == null && list2 == null)
            return null;
        if(list1 == null)
        {
            return list2;
        }

        if(list2 == null){
            return list1;
        }

        if(list1.val <= list2.val){
            list1.next = Merge(list1.next,list2);
            return list1;
        }else{
            list2.next = Merge(list1,list2.next);
            return list2;
        }
    }
}		

```
